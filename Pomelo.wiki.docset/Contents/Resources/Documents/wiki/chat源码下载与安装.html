<html><head prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns/fb# object: http://ogp.me/ns/object# article: http://ogp.me/ns/article# profile: http://ogp.me/ns/profile#">
<meta charset="utf-8">
<meta content="IE=edge" http-equiv="X-UA-Compatible">
<meta content="en" http-equiv="Content-Language">
<meta content="width=1020" name="viewport">
<title>Chat源码下载与安装 · NetEase/pomelo Wiki · GitHub</title>
<link href="/opensearch.xml" rel="search" title="GitHub" type="application/opensearchdescription+xml">
<link href="src/ad667adaa2cfe8f3caa4a41b7d0a79a1.png" rel="fluid-icon" title="GitHub">
<link href="src/a10d19ff5f738940a7a5086be334f50b.png" rel="apple-touch-icon" sizes="57x57">
<link href="src/a10d19ff5f738940a7a5086be334f50b.png" rel="apple-touch-icon" sizes="114x114">
<link href="src/b4cd268bc600cc14d2cdd557de6da2fb.png" rel="apple-touch-icon" sizes="72x72">
<link href="src/b4cd268bc600cc14d2cdd557de6da2fb.png" rel="apple-touch-icon" sizes="144x144">
<meta content="1401488693436528" property="fb:app_id">
<meta content="@github" name="twitter:site"/><meta content="summary" name="twitter:card"/><meta content="NetEase/pomelo" name="twitter:title"/><meta content="pomelo - A fast,scalable,distributed game server framework for Node.js." name="twitter:description"/><meta content="https://avatars0.githubusercontent.com/u/1460597?v=3&amp;s=400" name="twitter:image:src"/>
<meta content="GitHub" property="og:site_name"/><meta content="object" property="og:type"/><meta content="https://avatars0.githubusercontent.com/u/1460597?v=3&amp;s=400" property="og:image"/><meta content="NetEase/pomelo" property="og:title"/><meta content="https://github.com/NetEase/pomelo" property="og:url"/><meta content="pomelo - A fast,scalable,distributed game server framework for Node.js." property="og:description"/>
<meta content="https://api.github.com/_private/browser/stats" name="browser-stats-url">
<meta content="https://api.github.com/_private/browser/errors" name="browser-errors-url">
<link href="https://assets-cdn.github.com/" rel="assets">
<meta content="1000" name="pjax-timeout">
<meta content="/windows-tile.png" name="msapplication-TileImage">
<meta content="#ffffff" name="msapplication-TileColor">
<meta data-pjax-transient="" name="selected-link" value="repo_wiki">
<meta content="KT5gs8h0wvaagLKAVWq8bbeNwnZZK1r1XQysX3xurLU" name="google-site-verification">
<meta content="UA-3769691-2" name="google-analytics">
<meta content="collector.githubapp.com" name="octolytics-host"/><meta content="github" name="octolytics-app-id"/><meta content="7250A4CA:6924:139D337F:5670BFBE" name="octolytics-dimension-request_id"/>
<meta content="/&lt;user-name&gt;/&lt;repo-name&gt;/wiki/show" data-pjax-transient="true" name="analytics-location"/>
<meta content="Rails, view, wiki#show" data-pjax-transient="true" name="analytics-event"/>
<meta class="js-ga-set" content="Logged Out" name="dimension1">
<meta content="github.com" name="hostname">
<meta content="" name="user-login">
<meta content="github.com" name="expected-hostname">
<link color="#4078c0" href="https://assets-cdn.github.com/pinned-octocat.svg" rel="mask-icon">
<link href="https://assets-cdn.github.com/favicon.ico" rel="icon" type="image/x-icon">
<meta content="4c6340bdf8fe766a07daae03493d3a4b84ab81ac" name="form-nonce"/>
<link crossorigin="anonymous" href="src/350888e1495e7af27e01faa9d8291dee.css" media="all" rel="stylesheet"/>
<link crossorigin="anonymous" href="src/9fae9b7d8f0785d745a43c6465f74ae5.css" media="all" rel="stylesheet"/>
<meta content="cd9958d45e48e8e3157a320e9c346eaa" http-equiv="x-pjax-version">
<meta content="pomelo - A fast,scalable,distributed game server framework for Node.js." name="description">
<meta content="github.com/NetEase/pomelo git https://github.com/NetEase/pomelo.git" name="go-import">
<meta content="1460597" name="octolytics-dimension-user_id"/><meta content="NetEase" name="octolytics-dimension-user_login"/><meta content="5880912" name="octolytics-dimension-repository_id"/><meta content="NetEase/pomelo" name="octolytics-dimension-repository_nwo"/><meta content="true" name="octolytics-dimension-repository_public"/><meta content="false" name="octolytics-dimension-repository_is_fork"/><meta content="5880912" name="octolytics-dimension-repository_network_root_id"/><meta content="NetEase/pomelo" name="octolytics-dimension-repository_network_root_nwo"/>
<link href="https://github.com/NetEase/pomelo/commits/master.atom" rel="alternate" title="Recent Commits to pomelo:master" type="application/atom+xml">
</link></meta></meta></meta></link></link></meta></meta></meta></meta></meta></meta></meta></meta></meta></meta></link></meta></meta></meta></link></link></link></link></link></link></meta></meta></meta></meta></head><body style="padding:0 25px;"><div class="gollum-markdown-content instapaper_body" id="wiki-body">
<div class="markdown-body">
<p>在这一部分，我们来实现一个简易的分布式聊天应用，为了简单化，我们将直接从github上获取对应的源码，当然你也可以首先<code>pomelo init</code>,获得一个初始的项目目录，然后参照github上的源码，建立相应的目录，在默认的位置填充相应的源码。</p>
<h1>
<a aria-hidden="true" class="anchor" href="#%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84" id="user-content-源码结构"><span class="octicon octicon-link"></span></a>源码结构</h1>
<p>源码在github上面，通过如下命令，获得：</p>
<pre><code>$ git clone https://github.com/NetEase/chatofpomelo-websocket.git
$ git checkout tutorial-starter
</code></pre>
<p>这个是很简单的应用，其代码结构如下图：</p>
<p><img alt="源码结构图" src="src/77fdaf7a6db14548eb36fa9b75b8fd05.png"/></p>
<h4>
<a aria-hidden="true" class="anchor" href="#game-server" id="user-content-game-server"><span class="octicon octicon-link"></span></a>game-server</h4>
<p>game-server目录放的是所有游戏服务器的逻辑，以文件app.js作为入口，运行游戏的所有逻辑和功能。从图上可以看出其servers里面有三个目录，分别是gate，connector，chat。在pomelo中，使用路径来区分服务器类型，因此三个目录代表了三种不同类型的服务器，每一个目录下面可以定义handler,remote,定义了handler和remote就决定了这个服务器的行为。</p>
<ul>
<li><p>对于gate服务器，其逻辑实现代码在其gateHandler.js中，它接受客户端查询connector的请求，返回给客户端一个可以连接的connector的(ip,port);</p></li>
<li><p>connector服务器，其逻辑代码在entryHandler.js中，它主要完成接受客户端的请求，维护与客户端的连接，路由客户端的请求到chat服务器;</p></li>
<li><p>chat服务器，其既有handler代码，也有remote代码， handler中处理用户的send请求，而remote是当有用户加入或者退出的时候，由connector来发起远程调用时调用的。在remote里由于涉及到用户的加入和退出，所以会有对channel的操作。</p></li>
</ul>
<p>game-server 的子目录config下面是游戏服务器所用到的配置文件存放的地方，配置信息使用JSON格式，包含有日志，master服务器和其他服务器的配置信息。除了这个pomleo所需的配置信息外，一般情况下，也将游戏逻辑所需要的配置信息放到这个目录下，例如数据库的配置信息，地图信息等。</p>
<p>logs子目录下存放游戏服务器产生的所有的日志信息。 </p>
<h4>
<a aria-hidden="true" class="anchor" href="#web-server" id="user-content-web-server"><span class="octicon octicon-link"></span></a>web-server</h4>
<p>由于我们这个聊天应用的客户端是web，所以需要一个web服务器。在这个目录下，主要是客户端的js，css和静态资源等等。在本例子中，里面有用户登录，聊天的逻辑的js文件等等。我们在这个例子教程中，更多地关注的是服务器端的逻辑以及功能，对于客户端，我们几乎不需要怎么修改其代码，直接使用默认就好。</p>
<h1>
<a aria-hidden="true" class="anchor" href="#%E5%AE%89%E8%A3%85%E5%8F%8A%E8%BF%90%E8%A1%8C" id="user-content-安装及运行"><span class="octicon octicon-link"></span></a>安装及运行</h1>
<p>首先，确保你已经成功安装了pomelo。执行命令安装依赖:</p>
<pre><code>$ sh npm-install.sh
</code></pre>
<p>启动游戏服务器:</p>
<pre><code>$ cd game-server
$ pomelo start
</code></pre>
<p>启动web服务器:</p>
<pre><code>$ cd web-server
$ node app.js
</code></pre>
<p>如果启动过程中没有问题的话，下面我们就可以使用我们的聊天服务了，打开浏览器，输入<code>http://127.0.0.1:3001/index.html</code>, 输入一个用户名和一个房间名，就可以加入到聊天中了。可以多开几个客户端实例，测试chat是否能正常地运行，可以在一个房间里广播，也可以单个给某一个人发消息，效果图如下： </p>
<p><img alt="chat" src="src/dfc5e1ad7774fae13cfa9c6f2b73c055.png"/></p>
<h1>
<a aria-hidden="true" class="anchor" href="#chat%E5%88%86%E6%9E%90" id="user-content-chat分析"><span class="octicon octicon-link"></span></a>chat分析</h1>
<p>我们要搭建的pomelo聊天室具有如下的运行架构：</p>
<p><img alt="multi chat" src="src/1cbb2b7f4d62185ed2b05849eb7700fd.png"/></p>
<p>在这个架构里，前端服务器也就是connector专门负责承载连接， 后端的聊天服务器则是处理具体逻辑的地方。
 这样扩展的运行架构具有如下优势：</p>
<ul>
<li><p>负载分离：这种架构将承载连接的逻辑与后端的业务处理逻辑完全分离，这样做是非常必要的， 尤其是广播密集型应用（例如游戏和聊天）。密集的广播与网络通讯会占掉大量的资源，经过分离后业务逻辑的处理能力就不再受广播的影响。</p></li>
<li><p>切换简便：因为有了前、后端两层的架构，用户可以任意切换频道或房间都不需要重连前端的websocket。</p></li>
<li><p>扩展性好：用户数的扩展可以通过增加connector进程的数量来支撑。频道的扩展可以通过哈希分区等算法负载均衡到多台聊天服务器上。理论上这个架构可以实现频道和用户的无限扩展。</p></li>
</ul>
<h4>
<a aria-hidden="true" class="anchor" href="#%E5%AE%A2%E6%88%B7%E7%AB%AF" id="user-content-客户端"><span class="octicon octicon-link"></span></a>客户端</h4>
<p>聊天室的逻辑包括以下几个部分：</p>
<ul>
<li>  用户进入聊天室：这部分逻辑负责把用户信息注册到session，并让用户加入聊天室的channel。</li>
<li>  用户发起聊天： 这部分包括了用户从客户端发起请求，服务端接收请求等功能。</li>
<li>  广播用户的聊天： 所有在同一个聊天室的客户端收到请求并显示聊天内容。</li>
<li>  用户退出： 这部分需要做一些清理工作，包括session和channel的清理。</li>
</ul>
<p>客户端首先要给gate服务器查询一个connector服务器，gate给其回复一个connector的地址及端口号，这里没有列出完整的代码，具体的代码在路径web-server/public/js/client.js中,详细代码略去，见client.js:</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">function</span> <span class="pl-en">queryEntry</span>(<span class="pl-smi">uid</span>, <span class="pl-smi">callback</span>) {
  <span class="pl-k">var</span> route <span class="pl-k">=</span> <span class="pl-s"><span class="pl-pds">'</span>gate.gateHandler.queryEntry<span class="pl-pds">'</span></span>;
  <span class="pl-c">// ...</span>
}

<span class="pl-en">$</span>(<span class="pl-s"><span class="pl-pds">"</span>#login<span class="pl-pds">"</span></span>).<span class="pl-c1">click</span>(<span class="pl-k">function</span>() {
  username <span class="pl-k">=</span> <span class="pl-en">$</span>(<span class="pl-s"><span class="pl-pds">"</span>#loginUser<span class="pl-pds">"</span></span>).<span class="pl-en">attr</span>(<span class="pl-s"><span class="pl-pds">"</span>value<span class="pl-pds">"</span></span>);
  rid <span class="pl-k">=</span> <span class="pl-en">$</span>(<span class="pl-s"><span class="pl-pds">'</span>#channelList<span class="pl-pds">'</span></span>).<span class="pl-en">val</span>();

  <span class="pl-c">// ...</span>

 <span class="pl-c">//query entry of connection</span>
  <span class="pl-en">queryEntry</span>(username, <span class="pl-k">function</span>(<span class="pl-smi">host</span>, <span class="pl-smi">port</span>) {
    <span class="pl-smi">pomelo</span>.<span class="pl-en">init</span>({
      host<span class="pl-k">:</span> host,
      port<span class="pl-k">:</span> port,
      log<span class="pl-k">:</span> <span class="pl-c1">true</span>
    }, <span class="pl-k">function</span>() {
              <span class="pl-c">// ...</span>
    });
  });
});
</pre></div>
<p>客户端在查询到connector后，需要发请求给connector服务器， 第一次请求要给connector进程，因为首次进入时需要绑定对应的uid信息，这里略去详细代码:</p>
<div class="highlight highlight-source-js"><pre><span class="pl-smi">pomelo</span>.<span class="pl-en">request</span>(<span class="pl-s"><span class="pl-pds">'</span>connector.entryHandler.enter<span class="pl-pds">'</span></span>, {username<span class="pl-k">:</span> username, rid<span class="pl-k">:</span> rid}, <span class="pl-k">function</span>(){
  <span class="pl-c">// ...</span>
}); </pre></div>
<p>当用户发起聊天的时候，会请求服务chat.chatHandler.send，大致代码如下:</p>
<div class="highlight highlight-source-js"><pre><span class="pl-smi">pomelo</span>.<span class="pl-en">request</span>(<span class="pl-s"><span class="pl-pds">'</span>chat.chatHandler.send<span class="pl-pds">'</span></span>, {content<span class="pl-k">:</span>msg, from<span class="pl-k">:</span> username, target<span class="pl-k">:</span> <span class="pl-smi">msg</span>.<span class="pl-c1">target</span>}, <span class="pl-k">function</span>(<span class="pl-smi">data</span>) {
  <span class="pl-c">// ...</span>
});</pre></div>
<p>当有用户加入、离开以及发起聊天时，同房间的人将会收到服务端推送来的相应消息,这些在客户端是以回调的方式进行添加的，大致代码如下：</p>
<div class="highlight highlight-source-js"><pre>
<span class="pl-smi">pomelo</span>.<span class="pl-en">on</span>(<span class="pl-s"><span class="pl-pds">'</span>onAdd<span class="pl-pds">'</span></span>, <span class="pl-k">function</span>(<span class="pl-smi">data</span>) {
  <span class="pl-c">// ...</span>
});

<span class="pl-smi">pomelo</span>.<span class="pl-en">on</span>(<span class="pl-s"><span class="pl-pds">'</span>onLeave<span class="pl-pds">'</span></span>, <span class="pl-k">function</span>(<span class="pl-smi">data</span>) {
  <span class="pl-c">// ...</span>
});

<span class="pl-smi">pomelo</span>.<span class="pl-en">on</span>(<span class="pl-s"><span class="pl-pds">'</span>onChat<span class="pl-pds">'</span></span>, <span class="pl-k">function</span>(<span class="pl-smi">data</span>) {
  <span class="pl-c">// ...</span>
});
</pre></div>
<p>客户端的详细代码都在目录web-server/public/js/client.js文件中，这里，客户端的js是使用<a href="https://github.com/component/component">component</a>进行管理的,详细请参阅component的参考文档。</p>
<h3>
<a aria-hidden="true" class="anchor" href="#%E6%9C%8D%E5%8A%A1%E7%AB%AF" id="user-content-服务端"><span class="octicon octicon-link"></span></a>服务端</h3>
<p>我们知道，在pomelo中，只要定义了一个服务器的handler和remote，那么就定义了这个服务器的行为，就决定了这个服务器的类型。在本例子中，有三种服务器，gate，connector，chat,它们完成的具体逻辑如下:</p>
<ul>
<li>gate完成客户端对connector的查询，在其handler了里有其实现的代码，由于在这里，本例中仅仅配置了一台connector服务器，因此直接返回其信息给客户端即可，然后客户端就可以连接到connector了。</li>
</ul>
<div class="highlight highlight-source-js"><pre><span class="pl-c1">handler</span>.<span class="pl-en">queryEntry</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">msg</span>, <span class="pl-smi">session</span>, <span class="pl-smi">next</span>) {
    <span class="pl-k">var</span> uid <span class="pl-k">=</span> <span class="pl-smi">msg</span>.<span class="pl-smi">uid</span>;
    <span class="pl-c">// ...</span>
};</pre></div>
<ul>
<li>connector接受用户的连接，完成用户的注册及绑定，维护客户端session信息，处理客户端的断开连接，其逻辑代码在connector/handler/entryHandler.js中。大致如下：</li>
</ul>
<div class="highlight highlight-source-js"><pre><span class="pl-c1">handler</span>.<span class="pl-en">enter</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">msg</span>, <span class="pl-smi">session</span>, <span class="pl-smi">next</span>) {
    <span class="pl-k">var</span> self <span class="pl-k">=</span> <span class="pl-v">this</span>;
    <span class="pl-k">var</span> rid <span class="pl-k">=</span> <span class="pl-smi">msg</span>.<span class="pl-smi">rid</span>;
    <span class="pl-k">var</span> uid <span class="pl-k">=</span> <span class="pl-smi">msg</span>.<span class="pl-smi">username</span> <span class="pl-k">+</span> <span class="pl-s"><span class="pl-pds">'</span>*<span class="pl-pds">'</span></span> <span class="pl-k">+</span> rid
    <span class="pl-k">var</span> sessionService <span class="pl-k">=</span> <span class="pl-smi">self</span>.<span class="pl-smi">app</span>.<span class="pl-en">get</span>(<span class="pl-s"><span class="pl-pds">'</span>sessionService<span class="pl-pds">'</span></span>);
  <span class="pl-c">// .....</span>
};</pre></div>
<ul>
<li>chat服务器是执行聊天逻辑的地方，它维护channel信息，一个房间就是一个channel，一个channel里有多个用户，当有用户发起聊天的时候，就会将其内容广播到整个channel。chat服务器还会接受connector的远程调用，完成channel维护中的用户的加入以及离开，因此chat服务器不仅定义了handler，还定义了remote。当有客户端连接到connector上后，connector会向chat发起远程过程调用，chat会将登录的用户，加到对应的channel中，其大致代码为：</li>
</ul>
<div class="highlight highlight-source-js"><pre><span class="pl-c">// chatHandler.js</span>
<span class="pl-c1">handler</span>.<span class="pl-en">send</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">msg</span>, <span class="pl-smi">session</span>, <span class="pl-smi">next</span>) {
    <span class="pl-k">var</span> rid <span class="pl-k">=</span> <span class="pl-smi">session</span>.<span class="pl-en">get</span>(<span class="pl-s"><span class="pl-pds">'</span>rid<span class="pl-pds">'</span></span>);
    <span class="pl-k">var</span> username <span class="pl-k">=</span> <span class="pl-smi">session</span>.<span class="pl-smi">uid</span>.<span class="pl-c1">split</span>(<span class="pl-s"><span class="pl-pds">'</span>*<span class="pl-pds">'</span></span>)[<span class="pl-c1">0</span>];
    <span class="pl-c">// .....</span>
};

<span class="pl-c">// chatRemote.js</span>
<span class="pl-c1">ChatRemote</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">add</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">uid</span>, <span class="pl-smi">sid</span>, <span class="pl-smi">name</span>, <span class="pl-smi">flag</span>, <span class="pl-smi">cb</span>) {
    <span class="pl-k">var</span> channel <span class="pl-k">=</span> <span class="pl-v">this</span>.<span class="pl-smi">channelService</span>.<span class="pl-en">getChannel</span>(name, flag);
};

<span class="pl-c1">ChatRemote</span>.<span class="pl-c1">prototype</span>.<span class="pl-en">kick</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">uid</span>, <span class="pl-smi">sid</span>, <span class="pl-smi">name</span>) {
    <span class="pl-k">var</span> channel <span class="pl-k">=</span> <span class="pl-v">this</span>.<span class="pl-smi">channelService</span>.<span class="pl-en">getChannel</span>(name, <span class="pl-c1">false</span>);
  <span class="pl-c">// ...</span>
};</pre></div>
<ul>
<li>
<strong>注意</strong> 在实现具体的Handler的时候，最后需要调用next，其中next的签名为 next(err, resp).如果没有出现错误，那么err为空即可；如果不是request请求，而是notify的话，则一样需要调用next，此时resp参数是不需要的，一般情况下，如果没有错误的话，就直接使用<code>next(null)</code>即可。</li>
</ul>
<p>服务器配置信息在config目录下，现在我们只关注servers.json, master.json。master.json配置是master服务器的配置信息，包括地址端口号，servers.json配置具体的应用服务器信息。在配置文件中，分为development和production两种环境，表示开发环境和产品环境，我们在<code>pomelo start</code>后面可以通过-e可以指定使用哪个环境，更多帮助参见<code>pomelo start --help</code>。</p>
<h1>
<a aria-hidden="true" class="anchor" href="#%E5%B0%8F%E7%BB%93" id="user-content-小结"><span class="octicon octicon-link"></span></a>小结</h1>
<p>在这部分，我们下载了一个简单的聊天应用，并安装运行起来，并对其源码进行了分析。在本例子中，为了简单起见，我们对每一种类型仅仅配置一台服务器，其中对于前端服务器来说需要指定frontend为true。<a href="%E6%89%A9%E5%85%85%E6%9C%8D%E5%8A%A1%E5%99%A8" title="多台服务器">下一步</a>，我们将对每一种服务器类型配置多台服务器，以此来展示pomelo强大的可伸缩性。</p>
</div>
</div></body></html>