<html><head prefix="og: http://ogp.me/ns# fb: http://ogp.me/ns/fb# object: http://ogp.me/ns/object# article: http://ogp.me/ns/article# profile: http://ogp.me/ns/profile#">
<meta charset="utf-8">
<meta content="IE=edge" http-equiv="X-UA-Compatible">
<meta content="en" http-equiv="Content-Language">
<meta content="width=1020" name="viewport">
<title>Distributed Chat 분산 채팅 · NetEase/pomelo Wiki · GitHub</title>
<link href="/opensearch.xml" rel="search" title="GitHub" type="application/opensearchdescription+xml">
<link href="src/ad667adaa2cfe8f3caa4a41b7d0a79a1.png" rel="fluid-icon" title="GitHub">
<link href="src/a10d19ff5f738940a7a5086be334f50b.png" rel="apple-touch-icon" sizes="57x57">
<link href="src/a10d19ff5f738940a7a5086be334f50b.png" rel="apple-touch-icon" sizes="114x114">
<link href="src/b4cd268bc600cc14d2cdd557de6da2fb.png" rel="apple-touch-icon" sizes="72x72">
<link href="src/b4cd268bc600cc14d2cdd557de6da2fb.png" rel="apple-touch-icon" sizes="144x144">
<meta content="1401488693436528" property="fb:app_id">
<meta content="@github" name="twitter:site"/><meta content="summary" name="twitter:card"/><meta content="NetEase/pomelo" name="twitter:title"/><meta content="pomelo - A fast,scalable,distributed game server framework for Node.js." name="twitter:description"/><meta content="https://avatars0.githubusercontent.com/u/1460597?v=3&amp;s=400" name="twitter:image:src"/>
<meta content="GitHub" property="og:site_name"/><meta content="object" property="og:type"/><meta content="https://avatars0.githubusercontent.com/u/1460597?v=3&amp;s=400" property="og:image"/><meta content="NetEase/pomelo" property="og:title"/><meta content="https://github.com/NetEase/pomelo" property="og:url"/><meta content="pomelo - A fast,scalable,distributed game server framework for Node.js." property="og:description"/>
<meta content="https://api.github.com/_private/browser/stats" name="browser-stats-url">
<meta content="https://api.github.com/_private/browser/errors" name="browser-errors-url">
<link href="https://assets-cdn.github.com/" rel="assets">
<meta content="1000" name="pjax-timeout">
<meta content="/windows-tile.png" name="msapplication-TileImage">
<meta content="#ffffff" name="msapplication-TileColor">
<meta data-pjax-transient="" name="selected-link" value="repo_wiki">
<meta content="KT5gs8h0wvaagLKAVWq8bbeNwnZZK1r1XQysX3xurLU" name="google-site-verification">
<meta content="UA-3769691-2" name="google-analytics">
<meta content="collector.githubapp.com" name="octolytics-host"/><meta content="github" name="octolytics-app-id"/><meta content="CA86616A:448A:12087C2E:5670BFF8" name="octolytics-dimension-request_id"/>
<meta content="/&lt;user-name&gt;/&lt;repo-name&gt;/wiki/show" data-pjax-transient="true" name="analytics-location"/>
<meta content="Rails, view, wiki#show" data-pjax-transient="true" name="analytics-event"/>
<meta class="js-ga-set" content="Logged Out" name="dimension1">
<meta content="github.com" name="hostname">
<meta content="" name="user-login">
<meta content="github.com" name="expected-hostname">
<link color="#4078c0" href="https://assets-cdn.github.com/pinned-octocat.svg" rel="mask-icon">
<link href="https://assets-cdn.github.com/favicon.ico" rel="icon" type="image/x-icon">
<meta content="7509d727bda289ecbe582180fce4f9daae9960c0" name="form-nonce"/>
<link crossorigin="anonymous" href="src/350888e1495e7af27e01faa9d8291dee.css" media="all" rel="stylesheet"/>
<link crossorigin="anonymous" href="src/9fae9b7d8f0785d745a43c6465f74ae5.css" media="all" rel="stylesheet"/>
<meta content="cd9958d45e48e8e3157a320e9c346eaa" http-equiv="x-pjax-version">
<meta content="pomelo - A fast,scalable,distributed game server framework for Node.js." name="description">
<meta content="github.com/NetEase/pomelo git https://github.com/NetEase/pomelo.git" name="go-import">
<meta content="1460597" name="octolytics-dimension-user_id"/><meta content="NetEase" name="octolytics-dimension-user_login"/><meta content="5880912" name="octolytics-dimension-repository_id"/><meta content="NetEase/pomelo" name="octolytics-dimension-repository_nwo"/><meta content="true" name="octolytics-dimension-repository_public"/><meta content="false" name="octolytics-dimension-repository_is_fork"/><meta content="5880912" name="octolytics-dimension-repository_network_root_id"/><meta content="NetEase/pomelo" name="octolytics-dimension-repository_network_root_nwo"/>
<link href="https://github.com/NetEase/pomelo/commits/master.atom" rel="alternate" title="Recent Commits to pomelo:master" type="application/atom+xml">
</link></meta></meta></meta></link></link></meta></meta></meta></meta></meta></meta></meta></meta></meta></meta></link></meta></meta></meta></link></link></link></link></link></link></meta></meta></meta></meta></head><body style="padding:0 25px;"><div class="gollum-markdown-content instapaper_body" id="wiki-body">
<div class="markdown-body">
<h2>
<a aria-hidden="true" class="anchor" href="#why-chat" id="user-content-why-chat"><span class="octicon octicon-link"></span></a>Why chat?</h2>
<p>Pomelo is a game server framework, why does the tutorial starts from chat?</p>
<p>Pomelo is really a game server framework, but it is essentially a high real-time, scalable, multi-process application framework. In addition to some special parts of the game library in the library section, the rest of the framework can be used for development of real-time web application. And compared with some node.js real-time application frameworks such as derby, socketstream, meteor etc, it is more scalable.</p>
<p>Because of the complexity of the game in scene management, client animation, they are not suitable entry level application for the pomelo. Chat application is usually the first application which developers contact with node.js, and therefore more suitable for the tutorial.</p>
<p>Generally the beginner chat application of node.js is based on socket.io. Because it is based on single-process node.js, it hit a discount in scalability. For example, if you want to improve it to a multi-channels chat room like irc, the increased number of channels will inevitably lead the single-process node.js overloaded.</p>
<h2>
<a aria-hidden="true" class="anchor" href="#%EC%99%9C-%EC%B1%84%ED%8C%85%EC%9D%B8%EA%B0%80%EC%9A%94" id="user-content-왜-채팅인가요"><span class="octicon octicon-link"></span></a>왜 채팅인가요?</h2>
<p>포멜로는 게임 서버 프레임워크인데, 왜 튜토리얼을 채팅부터 시작 하나요?</p>
<p>포멜로 실제 게임 서버 프레임워크이지만, 본질적으로 굉장한 리얼타임, 확장성, 멀티 프로세스 응용 프로그램 프레임워크입니다.
라이브러리 섹션의 일부 특별한 게임 라이브러리뿐만 아니라, 프레임워크의 다른 부분들도 실시간 웹 어플리케이션의 개발을 위해 사용될 수 있습니다. 그리고 derby, socketstream, meteor등 일부 node.js의 실시간 애플리케이션 프레임워크에 비해 더 확장성이 있습니다.</p>
<p>게임에서 장면 관리(scene management), 클라이언트 애니메이션(client animation)의 복잡성 때문에, 포멜로의 입문 레벨 애플리케이션으로 적합하지 않습니다. 채팅 애플리케이션은 Node.js를 접하는 개발자들의 첫번째 애플리케이션으로 일반적이고, 튜토리얼로 더욱 적합합니다.</p>
<p>보통 Node.js의 시작 채팅 애플리케이션은 socket.io를 기반으로 합니다. Node.js는 싱글-프로세스 기반이기 때문에, 확장성의 이점이 날아가 버립니다. 예를들어, irc같은 멀티-채널 채팅 룸의 성능을 개선시키기 위해서, 채널의 수를 증가하면 싱글-프로세스의 Node.js는 오버로드가 필연적으로 생길 겁니다.</p>
<h2>
<a aria-hidden="true" class="anchor" href="#from-a-single-process-to-multi-process-from-socketio-to-pomelo" id="user-content-from-a-single-process-to-multi-process-from-socketio-to-pomelo"><span class="octicon octicon-link"></span></a>From a single process To multi-process, From socket.io To pomelo</h2>
<p>A native chat room application based socket.io, take <a href="http://github.com/joshmarshall/uberchat">uberchat</a> for example.</p>
<p>Its application architecture diagram is as below:</p>
<h2>
<a aria-hidden="true" class="anchor" href="#%EC%8B%B1%EA%B8%80-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EC%97%90%EC%84%9C-%EB%A9%80%ED%8B%B0-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EB%A1%9C-socketio%EC%97%90%EC%84%9C-pomelo%EB%A1%9C" id="user-content-싱글-프로세스에서-멀티-프로세스로-socketio에서-pomelo로"><span class="octicon octicon-link"></span></a>싱글 프로세스에서 멀티 프로세스로, socket.io에서 pomelo로</h2>
<p>기존 채팅룸 애플리케이션은 socket.io를 기본으로 합니다. 예를 들어 uberchat 입니다.</p>
<p>이 애플리케이션 아키텍처 다이어그램은 다음과 같습니다:</p>
<p><img alt="uberchat" data-canonical-src="http://pomelo.netease.com/resource/documentImage/uberchat.png" src="https://camo.githubusercontent.com/7d29c6c5ee66abe7f39c0a8defcc2138bc0603ea/687474703a2f2f706f6d656c6f2e6e6574656173652e636f6d2f7265736f757263652f646f63756d656e74496d6167652f75626572636861742e706e67"/></p>
<p>The server which only contains a single node.js process handle all requests from websocket.</p>
<p>It has following disadvantages:</p>
<ol>
<li><p>Poor scalability: it only supports single process node.js, can not be distributed according to room/channel, and can not separate broadcast pressure from logic business processing either.</p></li>
<li><p>Code redundancy: it just makes simple encapsulation of socket.io, and only the server side contains 430 lines of code.</p></li>
</ol>
<p>Using pomelo to write this framework can be completely overcome these shortcomings.</p>
<p>The distributed chat application architecture which we want to build is as follow:</p>
<p>오직 하나의 node.js 프로세스를 가지는 서버는 websocket에서 모든 요청을 처리 합니다.</p>
<p>이것은 다음과 같은 단점을 갖습니다. </p>
<ol>
<li><p>열악한 확장: 그것은 싱글 프로세스 Node.js만 서포트하며, 방/채널에 따라 분리 될 수 없으며, 비지니스 로직 처리에서 전파 presure를 떼어 놓을 수 없습니다.</p></li>
<li><p>코드 중복: socket.io의 캡슐화는 간단하게 하고, 서버 사이드만 430 라인을 포함합니다.</p></li>
</ol>
<p>포멜로의 사용으로 이런 단점들을 확실히 극복 할 수 있습니다.</p>
<p>우리가 만들기 원하는 분산 채팅 애플리케이션은 다음과 같습니다.</p>
<p><img alt="multi chat" data-canonical-src="http://pomelo.netease.com/resource/documentImage/multi_chat.png" src="https://camo.githubusercontent.com/da1170cd20d5264ccfd6f3ff755aab3d81002252/687474703a2f2f706f6d656c6f2e6e6574656173652e636f6d2f7265736f757263652f646f63756d656e74496d6167652f6d756c74695f636861742e706e67"/></p>
<p>In this architecture, the front-end servers named connector is responsible for holding connections, the chat server is in charge of processing business logic.</p>
<p>Such scale-up architecture has following advantages:</p>
<ul>
<li><p>Load separation: The architecture totally separates the connection code from the business logic code, and this is really necessary especially in broadcast-intensive application like game.Network communication can consume large amount of resource, however, the business logic processing  ability will not be influenced by broadcasting because of the separated architecture.</p></li>
<li><p>Simplify channel switch: Users can switch channels or rooms without reconnecting websocket because of this separated architecture.</p></li>
<li><p>Scale better: We can launch more connector processes to deal with the increase of users, and use hash algorithm to map channels to different servers.</p></li>
</ul>
<p>We will start to build this application with pomelo, and you will be amazed to find that it only takes less than 100 lines of code to build such a complex architecture.</p>
<p>이 아키텍처에서, 커넥터(connector)라는 이름의 프런트 엔드 서버는 연결을 유지 할 책임이 있고, 채팅 서버는 비즈니스 로직 처리를 담당 합니다.</p>
<p>이러한 스케일-업 구조는 다음 장점이 있습니다:</p>
<ul>
<li><p>로드 분리: 아키텍처는 연결 코드와 비즈니스 로직 코드를 완전히 분리하고 특히 게임 같은 전파-집약적인 애플리케이션에서는 정말 꼭 필요합니다. 네트워크 통신은 많은 양의 리소스를 소비할 수 있지만, 비즈니스 로직 처리 기능은 아키텍처의 분리로 인해 전파의 영향을 받지 않습니다. </p></li>
<li><p>채널 스위치 단순화: 이 아키텍처로 인해 사용자는 wobsocket 재연결 없이도 채널 또는 방을 전환 할 수 있습니다.</p></li>
<li><p>확장 추가: 우리는 사용자의 증가를 처리하기 위해서 커넥터 프로세스를 좀 더 실행 할 수 있으며, 다른 서버와 채널을 매핑하기 위해 해쉬 알고리즘을 사용할 수 있습니다.</p></li>
</ul>
<p>우리는 이 애플리케이션을 포멜로와 함께 만들기 시작 할 것이고, 당신은 이런 복잡한 아키텍처를 만드는데 코드가 100라인도 안된다는 것에 놀랄 것 입니다.</p>
<h2>
<a aria-hidden="true" class="anchor" href="#initialization-of-code-structure" id="user-content-initialization-of-code-structure"><span class="octicon octicon-link"></span></a>Initialization of Code Structure</h2>
<p>Application of the code structure can be initialized by using the following command:</p>
<h2>
<a aria-hidden="true" class="anchor" href="#%EC%BD%94%EB%93%9C-%EA%B5%AC%EC%A1%B0%EC%9D%98-%EC%B4%88%EA%B8%B0%ED%99%94" id="user-content-코드-구조의-초기화"><span class="octicon octicon-link"></span></a>코드 구조의 초기화</h2>
<p>애플리케이셔의 코드구조는 다음 명령어의 사용으로 초기화 됩니다.</p>
<blockquote>
<p>pomelo init chatofpomelo</p>
</blockquote>
<p>The code structure is shown below:</p>
<p>코드 구조는 다음과 같습니다 :</p>
<p><img alt="chat directory" data-canonical-src="http://pomelo.netease.com/resource/documentImage/chatDir.png" src="https://camo.githubusercontent.com/d9a45f06e69f2e0486add1a8d99e58ec667563a6/687474703a2f2f706f6d656c6f2e6e6574656173652e636f6d2f7265736f757263652f646f63756d656e74496d6167652f636861744469722e706e67"/></p>
<p>Description:</p>
<ul>
<li><p>game-server: all the game business logic code is in this directory.The file app.js is the entrance of the server, and all the game logic and functions start from here.</p></li>
<li><p>web-server: web server which used by game server(including login logic), the client js, css and static resources.</p></li>
<li><p>config: Generally, a project needs a lot of configurations and you can use JSON files here. In game project, some configurations have been created such as log, master-server and other servers at initialization. Also, you can add database, map and numerical tabular configuration etc.</p></li>
<li><p>logs: Logs are essential for the project and contain a lot of information which you can get the project runing state from.</p></li>
<li><p>shared: Both some configurations and code resources can be shared between front end and back end if you choose javascript as client language.</p></li>
</ul>
<p>설명:</p>
<ul>
<li><p>game-server: 모든 게임 비즈니스 로직 코드는 이 디렉토리에 있습니다. app.js파일은 서버의 시작이며, 모든 게임 로직와 기능이 여기에서 시작 합니다.</p></li>
<li><p>web-server: game-sever에 의해 사용 되는 web-server, 클라이언트 자바스크립트, css, static 리소스</p></li>
<li><p>config: 일반적으로 프로젝트는 많은 설정이 필요한데, 여기에 JSON 파일을 사용할 수 있습니다. 게임 프로젝트에서 일부 구성은 이러한 초기화에서 로그 마스터 서버와 다른 서버로 개발되었습니다. 또한 데이터베이스, 맵, 수치표 설정을 추가 할 수 있습니다.</p></li>
<li><p>로그 : 로그는 프로젝트에서 필수적이며, 프로젝트 실행 상태에서 가져올 수 있는 정보를 많이 포함하고 있습니다.</p></li>
<li><p>공유: 클라이언트 언어로 자바스크립트를 선택하면, 일부 설정 및 코드 리소스 모두 프론트엔드와 백엔드 사이에서 공유 될 수 있습니다.</p></li>
</ul>
<p>Initialization &amp;&amp; Test:</p>
<p>install npm package</p>
<blockquote>
<p>sh npm-install.sh</p>
</blockquote>
<p>start game server</p>
<blockquote>
<p>cd game-server &amp;&amp; pomelo start</p>
</blockquote>
<p>start web server</p>
<blockquote>
<p>cd web-server &amp;&amp; node app.js</p>
</blockquote>
<p>The web server contains the pomelo client code, when the web server is started, the client is automatically loaded into the browser. Clients send requests to the game server via websocket, the server can push messages to the client after connected by pomelo.</p>
<p>Visit http://localhost:3001, if the web server is running successfully, the following page will appear in  browser:</p>
<p>초기화 &amp;&amp; 테스트 :</p>
<p>npm package 설치</p>
<blockquote>
<p>sh npm-install.sh</p>
</blockquote>
<p>game server 시작</p>
<blockquote>
<p>cd game-server &amp;&amp; pomelo start</p>
</blockquote>
<p>web server 시작</p>
<blockquote>
<p>cd web-server &amp;&amp; node app.js</p>
</blockquote>
<p>web server가 시작될 때 web server는 포멜로 클라이언트 코드를 포함하고 클라이언트는 자동적으로 브라우저에 로드 됩니다.
클라이언트는 websocket를 통해서 요청(request)를 game server에 보내고, 서버는 포멜로에 연결 후 클라이언트에 메시지를 푸쉬(push)할 수 있습ㄴ다.</p>
<p>web server 실행이 완료하면 http://localhost:3001에 접속하면, 다음 페이지가 브라우져에 나타납니다.</p>
<p><img alt="welcome page" data-canonical-src="http://pomelo.netease.com/resource/documentImage/welcome.png" src="https://camo.githubusercontent.com/aeee01d08ae08c0fd2f16a460a2d9e2f3945f631/687474703a2f2f706f6d656c6f2e6e6574656173652e636f6d2f7265736f757263652f646f63756d656e74496d6167652f77656c636f6d652e706e67"/></p>
<p>Click the Test Game Server button, the pop of 'game server is ok.' verify the success of the client and server communication.</p>
<p>'Test Game Server' 버튼을 클릭해 'game server is ok.'이 팝업되고, 클라이언트와 서버 통신의 성공을 확인하세요.</p>
<h2>
<a aria-hidden="true" class="anchor" href="#lets-start-chat-logic-coding" id="user-content-lets-start-chat-logic-coding"><span class="octicon octicon-link"></span></a>Let's start Chat Logic Coding</h2>
<p>The logic of chat includes the following sections:</p>
<ul>
<li><p>Entering: this part of the logic is responsible for registering user information to session, and add user into the channel of chat room.</p></li>
<li><p>Chatting: this section includes sending requests from the client, and receiving requests by the server.</p></li>
<li><p>Broadcasting: all clients in the same chat room will receive messages and show messages in browser.</p></li>
<li><p>Leaving: this section needs to do some clean-up work, including cleaning up the session and channel information.</p></li>
</ul>
<h2>
<a aria-hidden="true" class="anchor" href="#%EC%B1%84%ED%8C%85-%EB%A1%9C%EC%A7%81-%EC%BD%94%EB%94%A9%EC%9D%84-%EC%8B%9C%EC%9E%91%ED%95%98%EC%9E%90" id="user-content-채팅-로직-코딩을-시작하자"><span class="octicon octicon-link"></span></a>채팅 로직 코딩을 시작하자</h2>
<p>채팅 로직은 다음과 같은 섹션이 포함되어 있습니다:</p>
<ul>
<li><p>Entering: 로직의 이부분은 유저 정보를 세션에 등록할 책임이 있으며, 채팅방 채널에 유저를 추가합니다.</p></li>
<li><p>Chatting: 이 섹션은 클라이언트의 요청을 전송하고 서버에서 요청을 수신하는 것을 포함합니다.</p></li>
<li><p>Broadcasting: 같은 채팅방에 있는 모든 클라이언트가 브라우저에서 메시지를 보내고 메시지를 봅니다.</p></li>
<li><p>Leaving: 이 섹션은 세션과 채널 정보를 지우는 정리 작업을 수행해야 합니다.</p></li>
</ul>
<h3>
<a aria-hidden="true" class="anchor" href="#entering" id="user-content-entering"><span class="octicon octicon-link"></span></a>Entering</h3>
<p>Entering page is as shown below:
User enters user name, name of chat room, user joins the chat room.</p>
<h3>
<a aria-hidden="true" class="anchor" href="#%EC%9E%85%EB%A0%A5" id="user-content-입력"><span class="octicon octicon-link"></span></a>입력</h3>
<p>입력 페이지는 아래와 같이 보여집니다:
유저는 이름, 채팅룸 이름을 입력하고, 채팅룸에 조인 합니다. </p>
<p><img alt="login" data-canonical-src="http://pomelo.netease.com/resource/documentImage/login.png" src="https://camo.githubusercontent.com/74c399ab310d68051dcad46cf5407b448a47d498/687474703a2f2f706f6d656c6f2e6e6574656173652e636f6d2f7265736f757263652f646f63756d656e74496d6167652f6c6f67696e2e706e67"/></p>
<h4>
<a aria-hidden="true" class="anchor" href="#client" id="user-content-client"><span class="octicon octicon-link"></span></a>Client</h4>
<p>Clients need to send a request to the server, the first request must route to the connector process, because the server needs to register the session information for the first time(page code layout in this tutorial omitted).</p>
<h4>
<a aria-hidden="true" class="anchor" href="#%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8-client" id="user-content-클라이언트-client"><span class="octicon octicon-link"></span></a>클라이언트 (Client)</h4>
<p>클라이언트는 요청을 서버로 보내야 하고, 처음 요청은 커넥터에 프로세스를 보내야 하는데, 서버는 최초에 세션 정보를 저장해야 하기 때문입니다(이번 튜토리얼에서 페이지 코드 레이아웃은 생략합니다).</p>
<div class="highlight highlight-source-js"><pre><span class="pl-smi">pomelo</span>.<span class="pl-en">request</span>(<span class="pl-s"><span class="pl-pds">'</span>connector.entryHandler.enter<span class="pl-pds">'</span></span>, {username<span class="pl-k">:</span> username}, <span class="pl-k">function</span>(){
}); </pre></div>
<p>The above request string 'connector.entryHandler.enter' representing the name of server type, the file name of the service and the corresponding method name respectively.</p>
<p>위의 요청 문자열 'connector.entryHandler.enter'은 서버 타입명, 서비스 파일명, 각 메서스명에 상응되는 것을 나타냅니다. </p>
<h4>
<a aria-hidden="true" class="anchor" href="#server" id="user-content-server"><span class="octicon octicon-link"></span></a>Server</h4>
<p>The connector can receive messages without any configuration, all you have to do is creating a new file named entryHandler.js under the connector/handler directory. We need to implement the enter method, and the server will automatically invoke the corresponding handler, the specific code is as follows:</p>
<h4>
<a aria-hidden="true" class="anchor" href="#%EC%84%9C%EB%B2%84-server" id="user-content-서버-server"><span class="octicon octicon-link"></span></a>서버 (Server)</h4>
<p>커넥터는 어떤 설정 없이도 메세지를 받을 수 있는데, 할 일은 커넥터/핸들러 디렉토리 아래에 entryHandler.js 파일을 만드는 것입니다. enter 메소드를 구현해야 하며, 서버는 자동으로 해당 핸들러를 작동시킬 것입니다. 세부 코드는 아래와 같습니다: </p>
<div class="highlight highlight-source-js"><pre><span class="pl-c1">handler</span>.<span class="pl-en">enter</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">request</span>, <span class="pl-smi">session</span>, <span class="pl-smi">next</span>) {
    <span class="pl-smi">session</span>.<span class="pl-en">bind</span>(uid);
    <span class="pl-smi">session</span>.<span class="pl-en">on</span>(<span class="pl-s"><span class="pl-pds">'</span>closed<span class="pl-pds">'</span></span>, <span class="pl-smi">onUserLeave</span>.<span class="pl-en">bind</span>(<span class="pl-c1">null</span>, <span class="pl-smi">this</span>.<span class="pl-smi">app</span>));
};</pre></div>
<h4>
<a aria-hidden="true" class="anchor" href="#server-add-user-into-channel" id="user-content-server-add-user-into-channel"><span class="octicon octicon-link"></span></a>Server add user into channel</h4>
<p>Using the rpc method to add the logged in user into the channel.</p>
<h4>
<a aria-hidden="true" class="anchor" href="#%EC%84%9C%EB%B2%84%EB%8A%94-%EC%9C%A0%EC%A0%80%EB%A5%BC-%EC%B1%84%EB%84%90%EC%97%90-%EC%B6%94%EA%B0%80%ED%95%A9%EB%8B%88%EB%8B%A4" id="user-content-서버는-유저를-채널에-추가합니다"><span class="octicon octicon-link"></span></a>서버는 유저를 채널에 추가합니다.</h4>
<p>로그한 유저를 채널에 추가하기 위해 rpc 메소드를 사용합니다. </p>
<div class="highlight highlight-source-js"><pre><span class="pl-smi">app</span>.<span class="pl-smi">rpc</span>.<span class="pl-smi">chat</span>.<span class="pl-smi">chatRemote</span>.<span class="pl-c1">add</span>(session, uid, <span class="pl-smi">app</span>.<span class="pl-en">get</span>(<span class="pl-s"><span class="pl-pds">'</span>serverId<span class="pl-pds">'</span></span>), <span class="pl-k">function</span>(<span class="pl-smi">data</span>){});</pre></div>
<p>app is the application object of pomelo, app.rpc represents the remote rpc call between the front and the end servers, the last three parameters correspond to the server name, the file name and the name of the method respectively. In order to finish this rpc call, you only need to create a new file named chatRemote.js in chat/remote directory, and implement the add method.</p>
<p>app은 포멜로의 애플리케이션 객체이고, app.rpc는 프론트와 끝단 서버 사이의 원격 rpc 호출을 나타내고, 마지막으로 3개의 파라메터들은 각가 서버명, 파일명, 메서드명에 해당 합니다. 이 RPC 호출을 완료하기 위해, 당신은 단지 chat/remote 디렉토리에 chatRemote.js 라는 이름의 새 파일을 생성하고, add 메서드를 구현하면 됩니다.</p>
<div class="highlight highlight-source-js"><pre><span class="pl-c1">handler</span>.<span class="pl-en">add</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">uid</span>, <span class="pl-smi">sid</span>, <span class="pl-smi">cb</span>){
    <span class="pl-k">var</span> channel <span class="pl-k">=</span> <span class="pl-smi">channelService</span>.<span class="pl-en">getChannel</span>(<span class="pl-s"><span class="pl-pds">'</span>pomelo<span class="pl-pds">'</span></span>, <span class="pl-c1">true</span>); 
    <span class="pl-k">if</span>(<span class="pl-k">!!</span>channel)
        <span class="pl-smi">channel</span>.<span class="pl-c1">add</span>(uid, sid);
};</pre></div>
<p>In the add method, firstly get the channel from channelService provided by pomelo, then add the user into the channel. This completes a full rpc call, in pomelo it is that easy to finish complex rpc call.</p>
<p>add 메서드에서, 첫째로 포멜로에서 제공되는 channelService에서 채널을 얻고(get), 다음엔 channel에 user를 추가합니다.
이것으로 전체 RPC 호출을 완료시키는데, 포멜로에서 이것은 복잡한 RPC 호출을 끝내는 쉬운 일입니다.</p>
<h4>
<a aria-hidden="true" class="anchor" href="#user-initiate-chatting-and-server-receive-message" id="user-content-user-initiate-chatting-and-server-receive-message"><span class="octicon octicon-link"></span></a>User initiate chatting and server receive message</h4>
<p>client code:</p>
<h4>
<a aria-hidden="true" class="anchor" href="#%EC%9C%A0%EC%A0%80%EB%8A%94-%EC%B1%84%ED%8C%85%EC%9D%84-%EC%8B%9C%EC%9E%91%ED%95%98%EA%B3%A0-%EC%84%9C%EB%B2%84%EB%8A%94-%EB%A9%94%EC%8B%9C%EC%A7%80%EB%A5%BC-%EB%B0%9B%EC%9D%8C" id="user-content-유저는-채팅을-시작하고-서버는-메시지를-받음"><span class="octicon octicon-link"></span></a>유저는 채팅을 시작하고 서버는 메시지를 받음</h4>
<p>클라이언트 코드:</p>
<div class="highlight highlight-source-js"><pre><span class="pl-smi">pomelo</span>.<span class="pl-en">request</span>(<span class="pl-s"><span class="pl-pds">'</span>chat.chatHandler.send<span class="pl-pds">'</span></span>, {content<span class="pl-k">:</span> msg, from<span class="pl-k">:</span> username, target<span class="pl-k">:</span> target}, <span class="pl-k">function</span>(){});</pre></div>
<p>server code:</p>
<p>서버 코드:</p>
<div class="highlight highlight-source-js"><pre><span class="pl-c1">handler</span>.<span class="pl-en">send</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">request</span>, <span class="pl-smi">session</span>, <span class="pl-smi">next</span>) {
 <span class="pl-k">var</span> param <span class="pl-k">=</span> {route<span class="pl-k">:</span> <span class="pl-s"><span class="pl-pds">'</span>onChat<span class="pl-pds">'</span></span>, msg<span class="pl-k">:</span> <span class="pl-smi">msg</span>.<span class="pl-c1">content</span>, from<span class="pl-k">:</span> <span class="pl-smi">msg</span>.<span class="pl-smi">from</span>, target<span class="pl-k">:</span> <span class="pl-smi">msg</span>.<span class="pl-c1">target</span>};
 <span class="pl-c">// send messages</span>
};</pre></div>
<h4>
<a aria-hidden="true" class="anchor" href="#server-broadcast-message-and-client-receive" id="user-content-server-broadcast-message-and-client-receive"><span class="octicon octicon-link"></span></a>Server broadcast message and client receive</h4>
<p>In server side, add the code into the send method:</p>
<h4>
<a aria-hidden="true" class="anchor" href="#%EC%84%9C%EB%B2%84%EB%8A%94-%EB%A9%94%EC%8B%9C%EC%A7%80%EB%A5%BC-%EC%A0%84%ED%8C%8C%ED%95%98%EA%B3%A0-%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8%EB%8A%94-%EB%B0%9B%EC%9D%8C" id="user-content-서버는-메시지를-전파하고-클라이언트는-받음"><span class="octicon octicon-link"></span></a>서버는 메시지를 전파하고 클라이언트는 받음</h4>
<p>서버 측에서 Send 메서드에 코드를 추가 :</p>
<div class="highlight highlight-source-js"><pre><span class="pl-k">var</span> channel <span class="pl-k">=</span> <span class="pl-smi">channelService</span>.<span class="pl-en">getChannel</span>(<span class="pl-s"><span class="pl-pds">'</span>pomelo<span class="pl-pds">'</span></span>, <span class="pl-c1">false</span>);
<span class="pl-smi">channel</span>.<span class="pl-en">pushMessage</span>(param);</pre></div>
<p>In client side, all users in the same channel receive and show messages.</p>
<p>클라이언트 측에서, 동일한 채널의 모든 사용자가 메시지를 수신하고 보여줍니다.</p>
<div class="highlight highlight-source-js"><pre><span class="pl-smi">pomelo</span>.<span class="pl-en">on</span>(<span class="pl-s"><span class="pl-pds">'</span>onChat<span class="pl-pds">'</span></span>, <span class="pl-k">function</span>() {
   <span class="pl-en">addMessage</span>(<span class="pl-smi">data</span>.<span class="pl-smi">from</span>, <span class="pl-smi">data</span>.<span class="pl-c1">target</span>, <span class="pl-smi">data</span>.<span class="pl-smi">msg</span>);
   $(<span class="pl-s"><span class="pl-pds">"</span>#chatHistory<span class="pl-pds">"</span></span>).<span class="pl-en">show</span>();
};</pre></div>
<h3>
<a aria-hidden="true" class="anchor" href="#leaving" id="user-content-leaving"><span class="octicon octicon-link"></span></a>Leaving</h3>
<p>When user's session is disconnected, remove the user from the channel.</p>
<h3>
<a aria-hidden="true" class="anchor" href="#%EB%82%98%EA%B0%80%EA%B8%B0" id="user-content-나가기"><span class="octicon octicon-link"></span></a>나가기</h3>
<p>유저의 세션이 끊어질때, 채널에서 유저를 제거합니다.</p>
<div class="highlight highlight-source-js"><pre><span class="pl-smi">app</span>.<span class="pl-smi">rpc</span>.<span class="pl-smi">chat</span>.<span class="pl-smi">chatRemote</span>.<span class="pl-en">kick</span>(session, <span class="pl-smi">session</span>.<span class="pl-smi">uid</span>, <span class="pl-smi">app</span>.<span class="pl-en">get</span>(<span class="pl-s"><span class="pl-pds">'</span>serverId<span class="pl-pds">'</span></span>), <span class="pl-s"><span class="pl-pds">'</span>pomelo<span class="pl-pds">'</span></span>, <span class="pl-c1">null</span>);</pre></div>
<p>Like entering into the chat room, add the kick method in chatRemote can achieve the functionality of user exits chat room.</p>
<p>채팅방에 입장하는 거와 같이, chatRemote에 유저가 채팅방을 나가는 기능 구현을 할 수 있는 킥(kick)메소드를 추가합니다.</p>
<div class="highlight highlight-source-js"><pre><span class="pl-c1">handler</span>.<span class="pl-en">kick</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">uid</span>, <span class="pl-smi">sid</span>, <span class="pl-smi">name</span>){
    <span class="pl-k">var</span> channel <span class="pl-k">=</span> <span class="pl-smi">channelService</span>.<span class="pl-en">getChannel</span>(name, <span class="pl-c1">false</span>);
    <span class="pl-k">if</span> (<span class="pl-k">!!</span>channel) {
        <span class="pl-smi">channel</span>.<span class="pl-en">leave</span>(uid,sid);
    }
};</pre></div>
<h2>
<a aria-hidden="true" class="anchor" href="#start" id="user-content-start"><span class="octicon octicon-link"></span></a>Start</h2>
<h3>
<a aria-hidden="true" class="anchor" href="#configure-serversjson" id="user-content-configure-serversjson"><span class="octicon octicon-link"></span></a>Configure servers.json</h3>
<p>the specific configuration is as follows：</p>
<h2>
<a aria-hidden="true" class="anchor" href="#%EC%8B%9C%EC%9E%91%ED%95%98%EA%B8%B0" id="user-content-시작하기"><span class="octicon octicon-link"></span></a>시작하기</h2>
<h3>
<a aria-hidden="true" class="anchor" href="#serversjson-%EC%84%A4%EC%A0%95%ED%95%98%EA%B8%B0" id="user-content-serversjson-설정하기"><span class="octicon octicon-link"></span></a>servers.json 설정하기</h3>
<p>상세 설정은 아래와 같습니다：</p>
<div class="highlight highlight-source-json"><pre>{
  <span class="pl-s"><span class="pl-pds">"</span>development<span class="pl-pds">"</span></span>:{
       <span class="pl-s"><span class="pl-pds">"</span>connector<span class="pl-pds">"</span></span>:[
            { <span class="pl-s"><span class="pl-pds">"</span>id<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>connector-server-1<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>host<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>127.0.0.1<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>port<span class="pl-pds">"</span></span>:<span class="pl-c1">3050</span> }
        ],
       <span class="pl-s"><span class="pl-pds">"</span>chat<span class="pl-pds">"</span></span>:[
            { <span class="pl-s"><span class="pl-pds">"</span>id<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>chat-server-1<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>host<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>127.0.0.1<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>port<span class="pl-pds">"</span></span>:<span class="pl-c1">6050</span> }
        ]
   },
  <span class="pl-s"><span class="pl-pds">"</span>production<span class="pl-pds">"</span></span>:{
       <span class="pl-s"><span class="pl-pds">"</span>connector<span class="pl-pds">"</span></span>:[
            { <span class="pl-s"><span class="pl-pds">"</span>id<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>connector-server-1<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>host<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>127.0.0.1<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>port<span class="pl-pds">"</span></span>:<span class="pl-c1">3050</span> }
        ],
       <span class="pl-s"><span class="pl-pds">"</span>chat<span class="pl-pds">"</span></span>:[
            { <span class="pl-s"><span class="pl-pds">"</span>id<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>chat-server-1<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>host<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>127.0.0.1<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>port<span class="pl-pds">"</span></span>:<span class="pl-c1">6050</span> }
        ]
   }
}</pre></div>
<p>The number of servers that developers can determine based on the number of users, which only need to add a line of code including server id, server type, host and port number in corresponding position in the configuration file.</p>
<p>유저의 숫자를 기준으로 개발자가 결정할 수 있는 서버의 숫자는 서버id, 서버type, 호스트(host), 포트(port) 숫자를 포함한 코드 라인을 설정 파일의 해당 위치에 추가 하기만 하면 됩니다.</p>
<h3>
<a aria-hidden="true" class="anchor" href="#run" id="user-content-run"><span class="octicon octicon-link"></span></a>Run</h3>
<h3>
<a aria-hidden="true" class="anchor" href="#%EC%8B%A4%ED%96%89%ED%95%98%EA%B8%B0" id="user-content-실행하기"><span class="octicon octicon-link"></span></a>실행하기</h3>
<blockquote>
<p>pomelo start</p>
</blockquote>
<h2>
<a aria-hidden="true" class="anchor" href="#scale-up" id="user-content-scale-up"><span class="octicon octicon-link"></span></a>scale up</h2>
<p>Next we can see the scale up in pomelo is so easy.</p>
<p>The architecture diagram now is below:</p>
<h2>
<a aria-hidden="true" class="anchor" href="#%EC%8A%A4%EC%BC%80%EC%9D%BC-%ED%99%95%EC%9E%A5" id="user-content-스케일-확장"><span class="octicon octicon-link"></span></a>스케일 확장</h2>
<p>다음은 포멜로에서 스케일 확인이 쉽다는 것을 볼 수 있습니다.</p>
<p>아키텍처 다이어그램은 이제 아래와 같습니다:</p>
<p><img alt="single chat" data-canonical-src="http://pomelo.netease.com/resource/documentImage/single_chat.png" src="https://camo.githubusercontent.com/4f1aa6fbc14b61752ee7b393dcac55cf00bb44ca/687474703a2f2f706f6d656c6f2e6e6574656173652e636f6d2f7265736f757263652f646f63756d656e74496d6167652f73696e676c655f636861742e706e67"/></p>
<p>If we want to scale up, we just need to modify servers.json.
스케일을 확장하려면, servers.json만 수정하면 됩니다.</p>
<div class="highlight highlight-source-json"><pre>{
  <span class="pl-s"><span class="pl-pds">"</span>development<span class="pl-pds">"</span></span>:{
       <span class="pl-s"><span class="pl-pds">"</span>gate<span class="pl-pds">"</span></span>:[
            { <span class="pl-s"><span class="pl-pds">"</span>id<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>gate-server-1<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>host<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>127.0.0.1<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>port<span class="pl-pds">"</span></span>:<span class="pl-c1">3014</span> }
        ],
       <span class="pl-s"><span class="pl-pds">"</span>connector<span class="pl-pds">"</span></span>:[
            { <span class="pl-s"><span class="pl-pds">"</span>id<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>connector-server-1<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>host<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>127.0.0.1<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>port<span class="pl-pds">"</span></span>:<span class="pl-c1">3050</span> },
            { <span class="pl-s"><span class="pl-pds">"</span>id<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>connector-server-2<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>host<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>127.0.0.1<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>port<span class="pl-pds">"</span></span>:<span class="pl-c1">3051</span> },
            { <span class="pl-s"><span class="pl-pds">"</span>id<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>connector-server-3<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>host<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>127.0.0.1<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>port<span class="pl-pds">"</span></span>:<span class="pl-c1">3052</span> }
        ],
       <span class="pl-s"><span class="pl-pds">"</span>chat<span class="pl-pds">"</span></span>:[
            { <span class="pl-s"><span class="pl-pds">"</span>id<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>chat-server-1<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>host<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>127.0.0.1<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>port<span class="pl-pds">"</span></span>:<span class="pl-c1">6050</span> }, 
            { <span class="pl-s"><span class="pl-pds">"</span>id<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>chat-server-2<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>host<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>127.0.0.1<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>port<span class="pl-pds">"</span></span>:<span class="pl-c1">6051</span> },
            { <span class="pl-s"><span class="pl-pds">"</span>id<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>chat-server-3<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>host<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>127.0.0.1<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>port<span class="pl-pds">"</span></span>:<span class="pl-c1">6052</span> }
        ]
   },
 <span class="pl-s"><span class="pl-pds">"</span>production<span class="pl-pds">"</span></span>:{
       <span class="pl-s"><span class="pl-pds">"</span>gate<span class="pl-pds">"</span></span>:[
            { <span class="pl-s"><span class="pl-pds">"</span>id<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>gate-server-1<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>host<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>127.0.0.1<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>port<span class="pl-pds">"</span></span>:<span class="pl-c1">3014</span> }
        ],
       <span class="pl-s"><span class="pl-pds">"</span>connector<span class="pl-pds">"</span></span>:[
            { <span class="pl-s"><span class="pl-pds">"</span>id<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>connector-server-1<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>host<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>127.0.0.1<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>port<span class="pl-pds">"</span></span>:<span class="pl-c1">3050</span> },
            { <span class="pl-s"><span class="pl-pds">"</span>id<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>connector-server-2<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>host<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>127.0.0.1<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>port<span class="pl-pds">"</span></span>:<span class="pl-c1">3051</span> },
            { <span class="pl-s"><span class="pl-pds">"</span>id<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>connector-server-3<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>host<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>127.0.0.1<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>port<span class="pl-pds">"</span></span>:<span class="pl-c1">3052</span> }
        ],
       <span class="pl-s"><span class="pl-pds">"</span>chat<span class="pl-pds">"</span></span>:[
            { <span class="pl-s"><span class="pl-pds">"</span>id<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>chat-server-1<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>host<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>127.0.0.1<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>port<span class="pl-pds">"</span></span>:<span class="pl-c1">6050</span> }, 
            { <span class="pl-s"><span class="pl-pds">"</span>id<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>chat-server-2<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>host<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>127.0.0.1<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>port<span class="pl-pds">"</span></span>:<span class="pl-c1">6051</span> },
            { <span class="pl-s"><span class="pl-pds">"</span>id<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>chat-server-3<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>host<span class="pl-pds">"</span></span>:<span class="pl-s"><span class="pl-pds">"</span>127.0.0.1<span class="pl-pds">"</span></span>, <span class="pl-s"><span class="pl-pds">"</span>port<span class="pl-pds">"</span></span>:<span class="pl-c1">6052</span> }
        ]
   }
}</pre></div>
<p>This way we easily change the single connector, chat server into multiple connector, chat server architecture. After scale up, there are more than one connector server in front, in order to balance the load of different connector servers, we add a gate server. The gate server is mainly responsible for allocate users in different connector servers, in this application we use the user name's hash value to select connector server.</p>
<p>The architecture diagram after scale up is as follow:</p>
<p>이 방법은 싱글 커넥터, 채팅 서버에서 멀티 커넥터, 채팅 서버 아키텍처로 쉽게 바꾸는 것입니다. 스케일 확장 후, 프론트에 커넥터를 한개 이상으로 하고, 다른 커넥터 서버들간에 로드 발란스를 위해 게이트(gate) 서버를 추가하였습니다. gate 서버는 주로 다른 커넥터 서버들에 유저를 할당하는데, 이 애플리케이션에서는 유저 이름의 해쉬 값을 커넥터 서버를 선택하는데 사용합니다.</p>
<p>스케일 확장 후 아키텍처 다이어그램은 아래와 같습니다.</p>
<p><img alt="multi chat" data-canonical-src="http://pomelo.netease.com/resource/documentImage/multi_chat.png" src="https://camo.githubusercontent.com/da1170cd20d5264ccfd6f3ff755aab3d81002252/687474703a2f2f706f6d656c6f2e6e6574656173652e636f6d2f7265736f757263652f646f63756d656e74496d6167652f6d756c74695f636861742e706e67"/></p>
<h3>
<a aria-hidden="true" class="anchor" href="#configure-router" id="user-content-configure-router"><span class="octicon octicon-link"></span></a>Configure router</h3>
<p>When extended to multiple servers, we need to add different routing configurations for different types of servers.The code below is the chat server routing configuration, in order to reduce application's complexity, we just do hash processing on room name, the detailed description of the configuration can refer to<a href="https://github.com/NetEase/pomelo/wiki/Reference-configuration-of-app.js">Reference configuration of app.js</a>。Specific code is as follow：</p>
<h3>
<a aria-hidden="true" class="anchor" href="#%EB%9D%BC%EC%9A%B0%ED%84%B0-%EA%B5%AC%EC%84%B1%ED%95%98%EA%B8%B0" id="user-content-라우터-구성하기"><span class="octicon octicon-link"></span></a>라우터 구성하기</h3>
<p>멀티 서버로 확장 할때, 서버 타입을 구별하기 위해 다른 라우팅 설정을 추가해야 합니다. 아래 코드는 설정의 복잡함을 줄이기 위한 채팅 서버 라우팅 설정인데, 방 이름으로 해쉬 처리한 것입니다. 자세한 설정에 관한 설명은 Reference configuration of app.js 문서를 참조 하세요. 상세 코드는 아래 입니다:</p>
<div class="highlight highlight-source-js"><pre><span class="pl-c">//routeUtil.js</span>
<span class="pl-c1">exp</span>.<span class="pl-en">chat</span> <span class="pl-k">=</span> <span class="pl-k">function</span>(<span class="pl-smi">session</span>, <span class="pl-smi">msg</span>, <span class="pl-smi">app</span>, <span class="pl-smi">cb</span>) {
    <span class="pl-k">var</span> chatServers <span class="pl-k">=</span> <span class="pl-smi">app</span>.<span class="pl-en">getServersByType</span>(<span class="pl-s"><span class="pl-pds">'</span>chat<span class="pl-pds">'</span></span>); 
    <span class="pl-k">if</span> (<span class="pl-k">!</span>chatServers) {
        <span class="pl-en">cb</span>(<span class="pl-k">new</span> <span class="pl-en">Error</span>(<span class="pl-s"><span class="pl-pds">'</span>can not find chat servers.<span class="pl-pds">'</span></span>));
        <span class="pl-k">return</span>;
    }
    <span class="pl-k">var</span> res <span class="pl-k">=</span> <span class="pl-smi">dispatcher</span>.<span class="pl-en">dispatch</span>(<span class="pl-smi">session</span>.<span class="pl-en">get</span>(<span class="pl-s"><span class="pl-pds">'</span>rid<span class="pl-pds">'</span></span>), chatServers);
    <span class="pl-en">cb</span>(<span class="pl-c1">null</span>, <span class="pl-smi">res</span>.<span class="pl-c1">id</span>);
};</pre></div>
<div class="highlight highlight-source-js"><pre><span class="pl-c">//app.js</span>
<span class="pl-smi">app</span>.<span class="pl-en">configure</span>(<span class="pl-s"><span class="pl-pds">'</span>production|development<span class="pl-pds">'</span></span>, <span class="pl-k">function</span>() {
       <span class="pl-smi">app</span>.<span class="pl-en">route</span>(<span class="pl-s"><span class="pl-pds">'</span>chat<span class="pl-pds">'</span></span>, <span class="pl-smi">routeUtil</span>.<span class="pl-smi">chat</span>);
});</pre></div>
<h1>
<a aria-hidden="true" class="anchor" href="#source-code" id="user-content-source-code"><span class="octicon octicon-link"></span></a>Source Code</h1>
<p>The tutorial source code can be obtained by using the following command:</p>
<blockquote>
<p>git clone <a href="https://github.com/NetEase/chatofpomelo.git">https://github.com/NetEase/chatofpomelo.git</a></p>
</blockquote>
<h1>
<a aria-hidden="true" class="anchor" href="#%EC%86%8C%EC%8A%A4-%EC%BD%94%EB%93%9C" id="user-content-소스-코드"><span class="octicon octicon-link"></span></a>소스 코드</h1>
<p>튜토리얼 소스 코드는 아래 명령어 사용으로 얻을 수 있습니다.</p>
</div>
</div></body></html>