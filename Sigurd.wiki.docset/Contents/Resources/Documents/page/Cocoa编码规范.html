<html><head>
<meta charset="utf-8">
<title>[iOS翻译] Cocoa编码规范 - CocoaChina_让移动开发更简单</title>
<meta content="iOS翻译,Cocoa,编码iPhone开发,iOS开发,iPad开发,Mac开发,苹果开发中文站,iPhone开发中文站,CocoaChina首页, Mac OS开发, Cocoa介绍,移动互联网,触控科技,Cocoa,Apple,developer,iOS,iPhone,iPad,iMac,iPod Touch,iPhone5,iPhone4S,iPad3,招聘,iPhone程序员,Objective-c,iPhone应用外包,ios6,ios面试,Cocos2d-x,cocos2d,iTunes,App Store,苹果开发" name="keywords"/>
<meta content="CocoaChina前身是全球成立最早规模最大的苹果开发中文站，现致力为所有移动开发者提供资讯服务、问答服务、代码下载、工具库及人才招聘服务" name="description"/>
<meta content="IE=edge" http-equiv="X-UA-Compatible">
<meta content="width=device-width, initial-scale=1" name="viewport">
<meta content="3300a939a1098c27e94457b75a0bb8c1" name="baidu-tc-cerfication"/>
<script type="text/javascript">
        function gotoMobilePage() {
            var sUserAgent = navigator.userAgent.toLowerCase();
            var agent_iphone = /iphone/i;
            var agent_android = /android/i;
            //var agent_ipad = /ipad/i;
            var agent_ipod = /ipod/i;
            var agent_wphone = /windows phone/i;
            if(agent_iphone.test(sUserAgent) || agent_android.test(sUserAgent) || agent_ipod.test(sUserAgent) || agent_wphone.test(sUserAgent)){
                var re = /\/\w+\/\d+\/(\d+)\.html/, 
                    result = re.exec(window.location.pathname);
                if ( result )
                {
                    window.location.href = "http://www.cocoachina.com/cms/wap.php?action=article&id=" + result[1];
                } else {
                    window.location.href = "http://m.cocoachina.com/";
                }
            }
        }
        gotoMobilePage(); 
    </script>
<link href="src/a84898c7e6056d1260de02fbe818b59e.css" media="all" rel="stylesheet">
<link href="src/fc35020aff41205c763aecda3951334a.css" media="all" rel="stylesheet">
<link href="src/d489a5f4b1e2af09b4874b9d8d44c7a2.css" rel="stylesheet">
<link href="src/b5f6d4d81287e6040d1271874f705098.css" rel="stylesheet">
<link href="src/a1959dceb4a4550b81d1eaa35f644180.css" rel="stylesheet"/>
<script src="src/a769fe53451c6abe32a2409f213c856c.js" type="text/javascript"></script>
<script src="src/878a1f110abba9b87695d6713e2423f4.js" type="text/javascript"></script>
<script src="src/78baea099161f999e575b28991cb48cf.js" type="text/javascript"></script>
</link></link></link></link></meta></meta></meta></head><body><div class="field_body" id="detailbody">
<p><span style="color: rgb(0, 176, 80);"></span></p><p style="text-align:center"><img alt="1441511061947863.jpg" border="0" src="src/a84ad8c678818e561e86ba5b4695b2dc.jpg" style="width: 500px; height: 332px;" title="1441511061947863.jpg" vspace="0"/></p><p><span style="color: rgb(0, 176, 80);"><strong>简介：</strong></span><br/></p><p>本文整理自Apple文档《Coding Guidelines for Cocoa》。这份文档原意是给Cocoa框架、插件及公共API开发者提供一些编码指导，实质上相当于Apple内部的编码规范。在多人协作时，一份统一的代码规范大大减少开发者之间的沟通成本，极力推荐。 </p><p><span style="color: rgb(0, 176, 80);"><strong>目录：</strong></span></p><p>一、代码命名基础</p><p>二、方法</p><p>三、函数</p><p>四、Property及其他</p><p>五、缩写  </p><p><span style="color: rgb(0, 176, 80);"><strong>一、代码命名基础</strong></span></p><p><span style="color: rgb(192, 0, 0);"><strong>1.通用原则</strong></span></p><p><strong>1.1 清晰</strong></p><p>尽量清晰又简洁，无法两全时清晰更重要</p><p style="text-align:center"><img alt="blob.png" src="src/ce5335482beeadf6412a1152e42b2a7e.png" title="1441509819955470.png"/></p><p>通常不应缩写名称，即使方法名很长也应完整拼写<br/></p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>你可能认为某个缩写众所周知，但其实未必，特别是你周围的开发者语言文化背景不同时</p></li><li><p>有一些历史悠久的缩写还是可以使用的，详见第五章</p></li></ul><p style="text-align:center"><img alt="blob.png" src="src/68f4a6ff8d5d64d43ad4d119d80db379.png" title="1441509896749042.png"/></p><p>API命名避免歧义，例如一个方法名有多种理解<br/></p><p><br/></p><p style="text-align:center"><img alt="blob.png" src="src/121c733f0655e7883becf144a93a2798.png" title="1441509905881130.png"/></p><p><strong>1.2 一致</strong><br/></p><p>尽力保持Cocoa编程接口命名一致</p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>如果有疑惑，请浏览当前头文件或者参考文档</p></li></ul><p>当某个类的方法使用了多态时，一致性尤其重要</p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>不同类里，功能相同的方法命名也应相同</p></li></ul><p><br/></p><p style="text-align:center"><img alt="blob.png" src="src/08fda87a6f60c5c8381f9239bda6f0ac.png" title="1441509959926816.png"/></p><p><strong>1.3 避免自引用（self Reference）</strong><br/></p><p>命名不应自引用</p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>这里的自引用指的是在词尾引用自身</p></li></ul><p style="text-align:center"><img alt="blob.png" src="src/beecc1814e0fc0ca1d114188b9e04f7e.png" title="1441509975783777.png"/></p><p>Mask与Notification忽略此规则<br/></p><p><strong><span style="color: rgb(192, 0, 0);"></span></strong></p><p style="text-align:center"><img alt="blob.png" src="src/be8a17e5a1628832af0ebc38a2a7c025.png" title="1441509984966357.png"/></p><p><strong><span style="color: rgb(192, 0, 0);">2.前缀</span></strong><br/></p><p>前缀是编程接口命名的重要部分，它们区分了软件的不同功能区域：</p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>前缀可以防止第三方开发者与Apple的命名冲突</p></li><ul class=" list-paddingleft-2" style="list-style-type: square;"><li><p>同样可以防止Apple内部的命名冲突</p></li></ul><li><p>前缀有指定格式</p></li><ul class=" list-paddingleft-2" style="list-style-type: square;"><li><p>它由二到三个大写字母组成，不使用下划线和子前缀</p></li></ul><li><p>命名类、协议、函数、常量和typedef结构体时使用前缀</p></li><ul class=" list-paddingleft-2" style="list-style-type: square;"><li><p>方法名不使用前缀（因为它存在于特定类的命名空间中）</p></li><li><p>结构体字段不使用前缀 </p></li></ul></ul><p><strong><span style="color: rgb(192, 0, 0);"></span></strong></p><p style="text-align:center"><img alt="blob.png" src="src/fecc65f5b556a04b648f4c6c098b0a60.png" title="1441510038800340.png"/></p><p><strong><span style="color: rgb(192, 0, 0);">3.书写约定</span></strong><br/></p><p>在命名API元素时， 使用驼峰命名法（如runTheWordsTogether），并注意以下书写约定：</p><p><strong>方法名</strong></p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>小写第一个字母，大写之后所有单词的首字母，不使用前缀</p></li><li><p>如果方法名以一个众所周知的大写缩略词开始，该规则不适用</p></li></ul><p>如TIFFRepresentation (NSImage)</p><pre class="brush:js;toolbar:false">fileExistsAtPath:isDirectory:</pre><p><strong>函数及常量名</strong></p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>使用与其关联类相同的前缀，并大写首字母</p></li></ul><pre class="brush:js;toolbar:false">NSRunAlertPanel
NSCellDisabled</pre><p><strong>标点符号</strong></p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>由多个单词组成的名称，别使用标点符号作为名称的一部分</p></li><ul class=" list-paddingleft-2" style="list-style-type: square;"><li><p>分隔符（下划线、破折号等）也不能使用</p></li></ul><li><p>避免使用下划线作为私有方法的前缀，Apple保留这一方式的使用</p></li><ul class=" list-paddingleft-2" style="list-style-type: square;"><li><p>强行使用可能会导致命名冲突，即Apple已有的方法被覆盖，这会导致灾难性后果</p></li><li><p>实例变量使用下划线作为前缀还是允许的</p></li></ul></ul><p><strong><span style="color: rgb(192, 0, 0);">4.class与protocol命名</span></strong></p><p><strong>class</strong></p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>class的名称应该包含一个名词，用以表明这个类是什么（或者做了什么），并拥有合适的前缀</p></li><li><p>如NSString、NSDate、NSScanner、UIApplication、UIButton</p></li></ul><p><strong>不关联class的protocol</strong></p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>大多数protocol聚集了一堆相关方法，并不关联class</p></li><li><p>这种protocol使用ing形式以和class区分开来</p></li></ul><p><br/></p><p style="text-align:center"><img alt="blob.png" src="src/42b82307a4a421ed2ba548cc7905d84e.png" title="1441510247983445.png"/></p><p><strong>关联class的protocol</strong><br/></p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>一些protoco聚集了一堆无关方法，并试图与某个class关联在一起，由这个class来主导</p></li><ul class=" list-paddingleft-2" style="list-style-type: square;"><li><p>这种protocol与class同名</p></li><ul class="custom_dash list-paddingleft-1"><li class="list-dash list-dash-paddingleft"><p>如NSObject protocol</p></li></ul></ul></ul><p><strong><span style="color: rgb(192, 0, 0);">5.头文件</span></strong></p><p>头文件的命名极其重要，因为它可以指出头文件包含的内容：</p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>声明一个孤立的class或protocol</p></li><ul class=" list-paddingleft-2" style="list-style-type: square;"><li><p>将声明放入单独的文件</p></li><li><p>使头文件名与声明的class/protocol相同</p></li></ul></ul><p style="text-align:center"><img alt="blob.png" src="src/699504ea64db85877751d2c8e23790bd.png" title="1441510258390459.png"/></p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>声明关联的class或protocol<br/></p></li><ul class=" list-paddingleft-2" style="list-style-type: square;"><li><p>将关联的声明（class/category/protocol）放入同一个头文件</p></li><li><p>头文件名与主要的class/category/protocol相同</p></li></ul></ul><p style="text-align:center"><img alt="blob.png" src="src/5d749097da85b3a725daee7b8d5ebfeb.png" title="1441510278719846.png"/></p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>Framework头文件<br/></p></li><ul class=" list-paddingleft-2" style="list-style-type: square;"><li><p>每个framework都应该有一个同名头文件</p></li><li><p>Include了框架内其他所有头文件</p></li></ul></ul><p style="text-align:center"><img alt="blob.png" src="src/d38117fc97be4c3807e98ef1507b6d12.png" title="1441510294801244.png"/></p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>添加API到另一个framework<br/></p></li><ul class=" list-paddingleft-2" style="list-style-type: square;"><li><p>如果要在一个framework中为另一个framework的class catetgory添加方法，加上单词“Additions” </p></li><ul class="custom_dash list-paddingleft-1"><li class="list-dash list-dash-paddingleft"><p>如Application Kit的NSBundleAdditions.h 文件</p></li></ul></ul><li><p>关联的函数、数据类型</p></li><ul class=" list-paddingleft-2" style="list-style-type: square;"><li><p>如果你有一组关联的函数、常量、结构体或其他数据类型，将它们放到一个名字合适的头文件中</p></li><ul class="custom_dash list-paddingleft-1"><li class="list-dash list-dash-paddingleft"><p>如Application Kit的NSGraphics.h </p></li></ul></ul></ul><p><span style="color: rgb(0, 176, 80);"><strong>二、方法</strong></span></p><p><strong><span style="color: rgb(192, 0, 0);">1.通用原则</span></strong><span style="color: rgb(192, 0, 0);"> </span></p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>以小写字母开始，之后单词的首字母大写</p></li><ul class=" list-paddingleft-2" style="list-style-type: square;"><li><p>以众所周知的缩写开始可以大写，如TIFF、PDF</p></li><li><p>私有方法可以加前缀                </p></li></ul><li><p>如果方法代表对象接收的动作，以动词开始</p></li><ul class=" list-paddingleft-2" style="list-style-type: square;"><li><p>不要使用 do 或 does 作为名字的一部分，因为助动词在这里很少有实际意义</p></li><li><p>同样的，也别在动词之前使用副词和形容词</p></li></ul></ul><pre class="brush:js;toolbar:false">- (void)invokeWithTarget:(id)target;
- (void)selectTabViewItem:(NSTabViewItem *)tabViewItem</pre><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>如果方法返回接收者的属性，以 接收者 + 接收的属性 命名</p></li><ul class=" list-paddingleft-2" style="list-style-type: square;"><li><p>除非间接返回多个值，否则不要使用 get 单词（为了与accessor methods区分） </p></li></ul></ul><p style="text-align:center"><img alt="blob.png" src="src/5440a2b57641391fad779183cf8e874f.png" title="1441510342242240.png"/></p><p>在所有参数之前使用关键字<br/></p><p style="text-align:center"><img alt="blob.png" src="src/8e0437d754ef6327db28bb966b77c86b.png" title="1441510350190909.png"/></p><p>确保参数之前的关键字充分描述了参数</p><p style="text-align:center"><img alt="blob.png" src="src/f30087ef194f13225458ca7d9f6cab1e.png" title="1441510357744281.png"/></p><p>创建自定义 init 方法时，记得指明关联的元素</p><p style="text-align:center"><img alt="blob.png" src="src/e6796e2d0e934af26f0636a7c8c3aaf5.png" title="1441510364456110.png"/></p><p>不要使用 and 来连接作为接收者属性的关键字</p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>虽然下面的例子使用 and 看似不错，但是一旦参数非常多时就容易出现问题</p></li></ul><p><span class="Apple-tab-span" style="white-space:pre"></span></p><p style="text-align:center"><img alt="blob.png" src="src/845dde146cec4dc44e873a1fe3b985ab.png" title="1441510376939244.png"/></p><p>除非方法描述了两个独立的操作，才使用 and 来连接它们<br/></p><p style="text-align:center"><img alt="blob.png" src="src/6af4cb26165d403699698e1111e89930.png" title="1441510386160791.png"/></p><p><strong><span style="color: rgb(192, 0, 0);">2.getter和setter方法（Accessor Methods）</span></strong></p><p>如果property表示为名词，格式如下</p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>- (type)noun;</p></li><li><p>- (void)setNoun:(type)aNoun;  </p></li><li><p>- (BOOL)isAdjective;</p></li></ul><pre class="brush:js;toolbar:false">- (NSString *)title;
- (void)setTitle:(NSString *)aTitle;</pre><p><span style="line-height: 1.8;">如果property表示为形容词，格式如下</span></p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>- (BOOL)isAdjective;</p></li><li><p>- (void)setAdjective:(BOOL)flag;  </p></li></ul><pre class="brush:js;toolbar:false">- (BOOL)isEditable; 
- (void)setEditable:(BOOL)flag;</pre><p><span style="line-height: 1.8;">如果property表示为动词，格式如下（动词用一般现在时）</span><br/></p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>- (BOOL)verbObject;</p></li><li><p>- (void)setVerbObject:(BOOL)flag;  </p></li></ul><pre class="brush:js;toolbar:false">- (BOOL)showsAlpha;
- (void)setShowsAlpha:(BOOL)flag;</pre><p><span style="line-height: 1.8;">不要把动词的过去分词形式当作形容词使用  </span></p><p style="text-align:center"><img alt="blob.png" src="src/7f9d77c444209fa9c0f1fdb321458c31.png" title="1441510445810397.png"/></p><p>你可能使用情态动词（can、should、will等）来增加可读性，不过不要使用 do或 does</p><p style="text-align:center"><img alt="blob.png" src="src/ff40fe5a8aae5b44875682d1e6df03f2.png" title="1441510455806266.png"/></p><p>只有方法需要间接返回多个值的情况下才使用 get</p><p>像这种接收多个参数的方法应该能够传入nil，因为调用者未必对每个参数都感兴趣</p><p style="text-align:center"><strong style="font-size: 14px; line-height: 25.2000007629395px; white-space: normal;"><span style="color: rgb(192, 0, 0);"><img alt="blob.png" src="src/fe1bf4a8b8e0883ebd5dff4b7eefa035.png" title="1441510465224919.png"/></span></strong></p><p><strong><span style="color: rgb(192, 0, 0);">3.Delegate方法</span></strong></p><p>以发送消息的对象开始</p><p>省略了前缀的类名和首字母小写</p><pre class="brush:js;toolbar:false">- (BOOL)tableView:(NSTableView *)tableView shouldSelectRow:(int)row; 
- (BOOL)application:(NSApplication *)sender openFile:(NSString *)filename;</pre><p>以发送消息的对象开始的规则不适用下列两种情况</p><p>只有一个sender参数的方法</p><pre class="brush:js;toolbar:false">- (BOOL)applicationOpenUntitledFile:(NSApplication *)sender;</pre><p>响应notification的方法（方法的唯一参数就是notification）</p><pre class="brush:js;toolbar:false">- (void)windowDidChangeScreen:(NSNotification *)notification;</pre><p>使用单词 did 和 will 来通知delegate</p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>did 表示某些事已发生</p></li><li><p>will 表示某些事将要发生</p></li></ul><pre class="brush:js;toolbar:false">- (void)browserDidScroll:(NSBrowser *)sender;
- (NSUndoManager *)windowWillReturnUndoManager:(NSWindow *)window;</pre><p>询问delegate是否可以执行某个行为时可以使用 did 或 will，不过 should 更完美  </p><pre class="brush:js;toolbar:false">- (BOOL)windowShouldClose:(id)sender;</pre><p><strong><span style="color: rgb(192, 0, 0);">4.集合方法 </span></strong><span style="color: rgb(192, 0, 0);"> </span> </p><p>为了管理集合中的元素，集合应该有这几个方法</p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>- (void)addElement:(elementType)anObj;</p></li><li><p>- (void)removeElement:(elementType)anObj;</p></li><li><p>- (NSArray *)elements;</p></li></ul><pre class="brush:js;toolbar:false">- (void)addLayoutManager:(NSLayoutManager *)obj;
- (void)removeLayoutManager:(NSLayoutManager *)obj;
- (NSArray *)layoutManagers;</pre><p>如果集合是无序的，返回一个NSSet比NSarray更好</p><p>如果需要在集合中的特定位置插入元素，使用类似下面的方法</p><pre class="brush:js;toolbar:false">- (void)insertLayoutManager:(NSLayoutManager *)obj atIndex:(int)index; 
- (void)removeLayoutManagerAtIndex:(int)index;</pre><p>其他集合方法示例</p><pre class="brush:js;toolbar:false">- (void)addChildWindow:(NSWindow *)childWin ordered:(NSWindowOrderingMode)place;
- (void)removeChildWindow:(NSWindow *)childWin;
- (NSArray *)childWindows;
- (NSWindow *)parentWindow;
- (void)setParentWindow:(NSWindow *)window;</pre><p><strong><span style="color: rgb(192, 0, 0);">5.方法参数 </span></strong></p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>参数名以小写字母开始，之后的单词首字母大写</p></li></ul><pre class="brush:js;toolbar:false">如：removeObject:(id)anObject</pre><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>别使用 ”pointer” 或 ”ptr” 命名</p></li><ul class=" list-paddingleft-2" style="list-style-type: square;"><li><p>参数类型里就已表明它是否是一个指针</p></li></ul><li><p><span style="line-height: 1.8;">避免只有一到二个字母的参数名</span></p></li><li><p>避免只有几个字母的缩写</p></li></ul><pre class="brush:js;toolbar:false">...action:(SEL)aSelector
...alignment:(int)mode
...atIndex:(int)index
...content:(NSRect)aRect
...doubleValue:(double)aDouble 
...floatValue:(float)aFloat 
...font:(NSFont *)fontObj  
...frame:(NSRect)frameRect 
...intValue:(int)anInt
...keyEquivalent:(NSString *)charCode
...length:(int)numBytes
...point:(NSPoint)aPoint
...stringValue:(NSString *)aString
...tag:(int)anInt
...target:(id)anObject
...title:(NSString *)aString</pre><p><span style="color: rgb(192, 0, 0);"><strong>6.私有方法</strong></span></p><p>不要使用下划线作为私有方法的前缀，Apple保留这一使用方式</p><p>因为若是你的私有方法名已被Apple使用，覆盖它将会产生极难追踪的BUG</p><p>如果继承自大型Cocoa框架（如UIView），请确保子类的私有方法名与父类不一样</p><p>可以为私有方法加一个前缀，如公司名或项目名：XX_</p><p>例如你的项目叫做Byte Flogger，那么前缀可能是：BF_addObject</p><p>总之，为子类的私有方法添加前缀是为了不覆盖其父类的私有方法</p><p><span style="color: rgb(0, 176, 80);"><strong>三、函数</strong></span></p><p>函数的命名类似方法，但有两点要注意</p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>你使用的类和常量拥有相同的前缀</p></li><li><p>前缀后的首字母大写</p></li></ul><p><span style="line-height: 1.8;">许多函数名以描述其作用的动词开始</span></p><pre class="brush:js;toolbar:false">NSHighlightRect
NSDeallocateObject</pre><p><span style="line-height: 1.8;">查询属性的函数有进一步的命名规则</span></p><p>如果函数返回首个参数的属性，省略动词</p><pre class="brush:js;toolbar:false">unsigned int NSEventMaskFromType(NSEventType type) 
float NSHeight(NSRect aRect)</pre><p>如果通过reference返回了值，使用 “Get”</p><pre class="brush:js;toolbar:false">const char *NSGetSizeAndAlignment(const char *typePtr, unsigned int *sizep, unsigned int *alignp)</pre><p>如果返回的是boolean值，应该灵活使用动词 </p><pre class="brush:js;toolbar:false">BOOL NSDecimalIsNotANumber(const NSDecimal *decimal)</pre><p><strong style="color: rgb(0, 176, 80); line-height: 1.8;">四、Property及其他</strong></p><p><span style="color: rgb(192, 0, 0);"><strong>1.Property与实例变量</strong></span></p><p><strong>1.1 Property</strong></p><p>Property命名规则与第二章accessor methods一样（因为两者紧密联系）</p><p>如果property表示为一个名词或动词，格式如下</p><p>@property (…) 类型 名词/动词 ;</p><pre class="brush:js;toolbar:false">@property (strong) NSString *title;
@property (assign) BOOL showsAlpha;</pre><p>如果property表示为一个形容词</p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>可省略 ”is” 前缀</p></li><li><p>但要指定getter方法的惯用名称</p></li></ul><pre class="brush:js;toolbar:false">@property (assign, getter=isEditable) BOOL editable;</pre><p><strong>1.2 实例变量</strong></p><p>通常不应该直接访问实例变量</p><p>init、dealloc、accessor methods等方法内部例外</p><p>实例变量以下划线 “_” 开始</p><p>确保实例变量描述了所存储的属性</p><pre class="brush:js;toolbar:false">@implementation MyClass {
   BOOL _showsTitle;
}</pre><p>如果想要修改property的实例变量名，使用 @synthesize语句</p><pre class="brush:js;toolbar:false">@implementation MyClass
@synthesize showsTitle=_showsTitle;</pre><p>为一个class添加实例变量时，有几点需要注意：</p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>避免声明公有实例变量</p></li><ul class=" list-paddingleft-2" style="list-style-type: square;"><li><p>开发者关注的应该是对象接口，而不是其数据细节</p></li><li><p>你可以通过使用property来避免声明实例变量</p></li></ul><li><p>如果需要声明实例变量，指定关键字@private 或 @protected</p></li><ul class=" list-paddingleft-2" style="list-style-type: square;"><li><p>如果你希望子类可以直接访问某个实例变量，使用 @protected 关键字</p></li></ul><li><p>如果一个实例变量是某个类可访问的属性，确保写了accessor methods</p></li><ul class=" list-paddingleft-2" style="list-style-type: square;"><li><p>如果有可能，还是使用property</p></li></ul></ul><p><strong style="color: rgb(192, 0, 0); line-height: 1.8;">2.常量  </strong></p><p><strong>2.1 枚举常量</strong></p><p>使用枚举来关联一组integer常量  </p><p>枚举常量和typedef遵循函数的命名规范，下面的例子是 NSMatrix.h</p><pre class="brush:js;toolbar:false">typedef enum _NSMatrixMode {
    NSRadioModeMatrix            = 0,
    NSHighlightModeMatrix       = 1,           
    NSListModeMatrix            = 2, 
    NSTrackModeMatrix           = 3
} NSMatrixMode;</pre><p>你可以为bit masks之类的东西创建一个匿名枚举 </p><pre class="brush:js;toolbar:false">enum { 
    NSBorderlessWindowMask       = 0, 
    NSTitledWindowMask           = 1 &lt;&lt; 0,
    NSClosableWindowMask         = 1 &lt;&lt; 1,
    NSMiniaturizableWindowMask   = 1 &lt;&lt; 2, 
    NSResizableWindowMask         = 1 &lt;&lt; 3
};</pre><p> <br/></p><p><strong>2.2 使用const关键字的常量 </strong></p><p>使用const关键字来创建一个float常量</p><p>你可以使用const关键字来创建一个与其他常量不相关的integer常量，否则，使用枚举</p><p>使用const关键字的常量也遵循函数的命名规则 </p><pre class="brush:js;toolbar:false">const float NSLightGray;</pre><p><strong>2.3 其他常量类型  </strong></p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>通常不应使用 #define 预编译指令来创建常量</p></li><ul class=" list-paddingleft-2" style="list-style-type: square;"><li><p>integer常量，使用枚举</p></li><li><p>float常量，使用 const 修饰符</p></li></ul><li><p>对 #define 预编译指令，大写所有字母</p></li><ul class=" list-paddingleft-2" style="list-style-type: square;"><li><p>比如 DEBUG 判断</p></li></ul></ul><pre class="brush:js;toolbar:false">#ifdef DEBUG</pre><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>注意宏命令的字首和字尾都有双下划线 </p></li></ul><pre class="brush:js;toolbar:false">__MACH__</pre><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>定义NSString常量来作为Notification和Key值</p></li><ul class=" list-paddingleft-2" style="list-style-type: square;"><li><p>这样做可以有效防止拼写错误</p></li></ul></ul><pre class="brush:js;toolbar:false">APPKIT_EXTERN NSString *NSPrintCopies;</pre><p><span style="color: rgb(192, 0, 0);"><strong>3.Notifications与Exceptions</strong></span></p><p><strong>3.1 Notifications  </strong></p><p>Notification的格式</p><pre class="brush:js;toolbar:false">[Name of associated class] + [Did | Will] + [UniquePartOfName] + Notification</pre><pre class="brush:js;toolbar:false">NSApplicationDidBecomeActiveNotification
NSWindowDidMiniaturizeNotification 
NSTextViewDidChangeSelectionNotification
NSColorPanelColorDidChangeNotification</pre><p><strong>3.2 Exceptions  </strong></p><ul class=" list-paddingleft-2" style="list-style-type: disc;"><li><p>Exception的格式</p></li></ul><pre class="brush:js;toolbar:false">[Prefix] + [UniquePartOfName] + Exception</pre><pre class="brush:js;toolbar:false">NSColorListIOException
NSColorListNotEditableException
NSDraggingException  
NSFontUnavailableException
NSIllegalSelectorException</pre><p><span style="color: rgb(0, 176, 80);"><strong>五、缩写</strong></span></p><p>设计编程接口时通常不应使用缩写，但下列已被广泛使用的缩写名称除外</p><p>标准C库中的缩写名，如：alloc、init</p><p>参数名可自由使用缩写，如：imageRep、col、obj、otherWin</p><p style="text-align:center"><img alt="blob.png" src="src/61c7dcb806ec6cf56fc67ff483f7e8f1.png" title="1441510759586621.png"/></p><p style="text-align:center"><img alt="blob.png" src="src/c9ec2bc6d4afd168d74ee970662099a6.png" title="1441510770883289.png"/></p>
</div></body></html>